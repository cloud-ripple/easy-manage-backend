1.查询部门思路
浏览器/客户端
    |
DeptController :接收请求、调用service查询部门、响应封装Result
    |
DeptService：调用mapper接口查询
    |
DeptMapper: select * from tb_dept;
    |
    数据库

1. 登录认证-登录校验-会话技术
会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。
会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。
会话跟踪方案：
    客户端会话跟踪技术：Cookie
    服务端会话跟踪技术：Session
    令牌技术 (当前企业开发中主流)

2. JWT令牌
全称：JSON Web Token  (https://jwt.io/)
定义了一种简洁的、自包含的格式，用于在通信双方以 json 数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。

3.登录校验-JWT令牌
令牌生成：登录成功后，生成JWT令牌，并返回给前端
令牌校验：在请求到达服务端后，对令牌进行统一拦截、校验。

用户登录成功后，系统会自动下发JWT令牌，然后在后续的每次请求中，都需要在请求头 header中携带到服务端，请求头的名称为 token
值为登录时下发的JWT令牌。
如果检测到用户未登录，则会返回如下固定错误信息：{"code": 0, "msg": "NOT_LOGIN", "data": null}

4.过滤器 Filter
是JavaWeb三大组件(Servlet, Filter, Listener)之一。
过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。
过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理、敏感字符处理等。

思考：
所有的请求，拦截到了之后，都需要校验令牌吗？ 有一个例外，登录请求 (因为JWT令牌是在用户登录成功后才下发的)
拦截到请求后，什么情况下才可以放行，执行业务操作？ 有JWT令牌，且令牌有效校验通过(合法)，否则都返回未登录错误结果

登录校验Filter-流程
步骤：
1. 获取请求url
2. 判断请求url中是否包含login，如果包含，说明是登录操作，直接放行
3. 获取请求头中的令牌(token)
4. 判断令牌是否存在，如果不存在，返回错误结果(未登录)
5. 解析Token，如果解析失败，返回错误结果(未登录)
6. 放行

5. 异常处理
三层架构调用顺序： Controller层(请求响应) ----调用---> Service层(逻辑处理) ---->调用----> Mapper层(数据操作)
一旦Mapper层出现了异常，即数据库操作出现了问题，比如：sql语法错误。此时会把产生的异常抛给调用者 Service层，而该层也没有做异常处理
接着把异常往上抛给Controller层，而该层也不做异常处理，而是交给全局异常处理器来处理----> 处理完成后，再给前端响应标准统一的响应结果 Result(封装相关错误信息)。

方案一：在Controller的方法中进行 try...catch处理   --- 代码臃肿，不推荐，因为有很多方法
方案二：全局异常处理器  --- 简单、优雅、推荐


6. spring事务管理
事务：是一组操作的集合，它是一个不可分割的工作单位，这些操作 要么同时成功，要么同时失败。
操作：
开启事务(一组操作开始前，开启事务): start transaction / begin;
提交事务(这组操作全部成功后，提交事务): commit ;
回滚事务(中间任何一个操作出现异常，回滚事务): rollback ;

案例：
解散部门：删除部门，同时删除该部门下的员工

6.1 spring事务管理
注解：@Transactional
位置：业务层Service 方法上、类上、接口上  -- 因为业务层中一个业务功能(方法)可能会涉及多个数据访问的操作
如果在方法上声明该注解，则代表把该方法交给spring进行事务管理，在类上，代表把该类的所有方法都交给spring事务管理
在接口上，则该接口的所有实现类的方法都交给spring事务管理
作用：将当前方法交给spring进行事务管理，方法执行前，底层会自动开启事务，成功执行完毕，提交事务，出现异常，回滚事务。

注解：@Transactional 一般选择加在业务层Service的增删改方法上(并且该方法有多个数据访问的操作)，因为查询操作并不会影响数据的变更，无须控制事务


7. AOP
面向切面编程，其实就是面向特定方法编程。
场景：案例部分功能运行较慢，定位执行耗时较长的业务方法，此时需要统计每一个业务方法的执行耗时。
实现：动态代理是面向切面编程最主流的实现。而SpringAOP是spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程。
步骤：统计各个业务层方法执行耗时
    导入依赖：在 pom.xml 中导入AOP的依赖
    编写AOP程序：针对于特定方法根据业务需要进行编程

7.1 AOP核心概念
连接点：JoinPoint，可以被AOP控制的方法(暗含方法执行时的相关信息)
通知：Advice，指哪些重复的逻辑，也就是共性功能(最终体现为一个方法)
切入点：PointCut，匹配连接的条件，通知仅会在切入点方法执行时被应用
切面：Aspect，描述通知与切入点的对应关系(通知 + 切入点)
目标对象：Target，通知所应用的对象

7.2 通知类型
(1) @Around: 环绕通知，此注解标注的通知方法在目标方法前、后都被执行
(2) @Before: 前置通知，此注解标注的通知方法在目标方法前被执行
(3) @After: 后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行
(4) @AfterReturning: 返回通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行
(5) @AfterThrowing: 异常后通知，此注解标注的通知方法发生异常后执行
注意：
@Around 环绕通知需要自己调用 ProceedingJoinPoint.proceed() 方法来让原始方法执行，其它通知不需要考虑目标方法执行。
@Around 环绕通知方法的返回值，必须指定为 Object，来接收原始方法的返回值。



当然以下是总结Spring Boot+Vue.js项目的PowerPoint演示文稿模板：

幻灯片1：标题幻灯片
项目名称
团队成员
日期

幻灯片2：简介
项目概况
项目目的
使用的技术（Spring Boot，Vue.js）

幻灯片3：弹簧套概述
简要解释Spring Boot
使用Spring Boot的功能和好处

幻灯片4:Vue.js概述
简要解释Vue.js
使用Vue.js的功能和好处

幻灯片5：体系结构概述
项目高层架构图
组件及其交互（Spring Boot后端，Vue.js前端）


幻灯片6：后端开发
描述后端开发过程
使用Spring Boot实现的关键功能
API端点和服务


幻灯片7：前端开发
描述前端开发过程
使用Vue.js实现的关键功能
组件及其功能


幻灯片8：数据库集成
描述数据库如何与项目集成
提到使用的数据库技术（MySQL、PostgreSQL等）
数据建模和模式设计

幻灯片9：部署
解释部署过程
服务器基础架构（如果适用）
使用的构建和部署工具（例如Maven、Jenkins）

幻灯片10：面临的挑战
讨论项目过程中遇到的挑战
团队如何应对这些挑战

幻灯片11：经验教训
分享项目期间的经验教训
发现或采用的最佳实践
对未来项目的建议

幻灯片12：结论
项目成果
最后的思考和思考
鸣谢（如有）

幻灯片13：问题和讨论
为观众提问和讨论提供幻灯片

幻灯片14：联系信息
为团队成员提供联系信息
电子邮件地址或LinkedIn个人资料


项目总结：
1. 该项目打通了从前端 Vue => MySQL => Java Web => SSM => Spring Boot => Maven 这一套技术栈
2. 熟练使用像 Postman、MySQL 图形界面等开发工具
3. 更加了解登录校验（JWT令牌）、文件上传等常见业务的实践，以及AOP 应用、SpringBoot 原理、Maven 高级等进阶知识
最后，通过本次项目实践开发终于入门了springboot，以及web开发这些东西，美中不足，我对前后端的联动不太了解。
直接用主流的springboot开发，为后面打下基础，又能快速熟悉项目开发流程。尤其是新版的前端环境搭建，vue+elementUI界面制作。
让我能够快速基于现在企业主流开发技术进行项目的开发，明白了整个开发流程和技术有哪些。我个人认为学做完这个项目以后还需要去详细学一下SSM框架，虽然现在都说过时了，
但需要了解一下，至少把Mybatis学一下，然后Spring和Spring mvc就看个人情况。当然细学Mybatis的时候也可以不全学，直接学注解开发，前边那种老套的比较繁琐，
虽然有助于理解但是感觉学了注解就不用了。我现在的感受就是，学了老师的Spring boot，感觉再回去学SSM好麻烦。



